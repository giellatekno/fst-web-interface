{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-even-is-this","title":"What even is this?","text":"<p>fst-web-interface is a web-based set of language tools, primarily aimed at linguists. There are tools for paradigm generation, analysis, etc, for a number of languages, some better than others, that the Giellatekno group develops language models for.</p> <p>fst-web-interface replaces the cgi-bin-based setup, which can currently be seen at giellatekno.uit.no</p>"},{"location":"#architechture","title":"Architechture","text":"<p>fst-web-interface consists of two parts: a client-side Svelte web app, and a server-side FastAPI API.</p> <p>The API uses the normal hfst tool-chain with the Giellatekno language models to provide results to queries coming from the client-side.</p> <p>For everything related to hfst and the Giellatekno language models, check out Giellatekno documentation.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>api/                   -- API sub-project directory\n    main.py            -- entry point of the FastAPI app\n    toolset.py         -- defines what a \"tool\" is\n    toolspecs/         -- the tools, and how they invoke hfst to produce results\nclient/                -- The Svelte client-side app\n    index.html         -- Skeleton html for svelte\n    locales/           -- localization\n        data/          -- locale data, stored in XML files (brought over from the previous\n                          Apache Forrest-based solution\n        {lang}.json    -- the compiled locale data for that language\n        xmltojson.py\n        make_final.py  -- scripts for compiling the stuff in /data to {lang}.json\n    package.json\n    package-lock.json\n    node_modules/      -- standard package info and packages in js projects\n    vite.config.js\n    svelte.config.js\n    jsconfig.json      -- configuration files for the tools\ndocs/                  -- documentation\n    README.md          -- documentation documentation\n    mkdocs.yml         -- mkdocs configuration file\n    docs/              -- markdown files of the actual documentation\ncgi-scripts/           -- a copy of the old cgi scripts, for reference\nperl_extractions/      -- a temporary place with some python translations of some perl scripts\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#project-layout","title":"Project layout","text":"<pre><code>main.py            -- entry point\ntoolset.py         -- defines what a tool is\ntoolspecs/         -- individual tool specifications\nconfig.py          -- Reads system configuration\n                      Note: NOT a place to configure how the api will behave\nutil.py            -- Various utilities\n</code></pre>"},{"location":"api/#routes","title":"Routes","text":"<p>The API exposes one route per tool. They take their arguments on the path of the url. Language and input is also taken in on the path.</p> <p>The simplest way to explain how the path looks for the tool routes, is this:</p> <pre><code>/{tool}/{lang}/{input}\n</code></pre> <p>That is, if a user is exploring the <code>\"analyze\"</code> tool for north sami (<code>\"sme\"</code>), and writes down the input <code>\"viessu\"</code>, the query path will be</p> <pre><code>/analyze/sme/viessu\n</code></pre> <p>Note</p> <p>FastAPI automatically documents the routes in the API using OpenAPI. They can be read at /docs or /redoc. The /docs one can be used to test out queries to the API. It's also possible to use a tool like hoppscotch to run test queries against the API.</p>"},{"location":"api/#architecture","title":"Architecture","text":"<p>Routes in the API is dynamically imported from the toolspecs/ folder.</p> <p>One file in the toolspecs/ folder corresponds to one route.</p>"},{"location":"api/#tools","title":"Tools","text":"<p>Tools are python files located in the toolspecs/ folder. They are python scripts, but certain variable names will be interpreted and read specially. Defining a name summary as a string will make that string show up in the OpenAPI documentation. A longer description can also be given. What the tool does is specified by the variable named pipeline.</p>"},{"location":"api/#pipeline","title":"pipeline","text":"<p>Can be either a dictionary or a list. If it is a dictionary, the keys are strings of 3-letter iso language names, and the value is a pipeline list of that language. The special key <code>\"*\"</code> will be used for all languages that are not specified.</p>"},{"location":"api/#pipeline-list","title":"pipeline list","text":"<p>A pipeline list (which is just a normal python list) consists of a series of steps that will be done in sequence. The input to the first step is the input from the route. The output from the last step is the return value of the route. Each step takes input from it</p> <p>A pipeline list (which is just a normal python list) specifies the operations that this tool will do to its input. Each entry in the list can be either a list or a function. If it is a function (async or not), it will be called, and the output will be the input for the next step.</p> <pre><code>route input =&gt; step1 =&gt; step2 =&gt; stepN =&gt; response from route\n</code></pre>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#overview","title":"Overview","text":"<p>The client and the api are deployed independently, each built as a docker image, and deployed on Azure. The specific Azure \"product\" that runs a docker image, and exposes it on a url, is named \"Azure Container Instances\".</p>"},{"location":"deployment/#client","title":"Client","text":"<p>Svelte builds into static html/css/js, and can be served by any web server. It is a SPA, so webservers will have to route all requests to index.html.</p>"},{"location":"deployment/#build-and-deploy","title":"Build and deploy","text":"<ol> <li>Build static html/css/js: <code>npm run build</code></li> <li>Make the nginx image that serves these static assets: <code>make image</code></li> <li>Tag the image: <code>docker tag fst-client gtfstcontainerregistry.azurecr.io/fst-client:latest</code></li> <li>Push the image to the container registry: <code>docker push gtfstcontainerregistry.azurecr.io/fst-client:latest</code></li> <li>If you have deployed before, see 5a, otherwise, for first time deply, see 5b.<ol> <li>Restart the container (will pull the new image): <code>az container restart --name fst-client --resource-group test-fst</code></li> <li><code>az container create --name fst-client --resource-group test-fst ...</code></li> </ol> </li> </ol> <p>The first 4 steps are the same either way, so here they are for convenience:</p> <pre><code>cd client/\nnpm run build\nmake image\ndocker tag fst-client gtfstcontainerregistry.azurecr.io/fst-client:latest\ndocker push gtfstcontainerregistry.azurecr.io/fst-client:latest\n# if you have deployed before\n# az container restart --name fst-client --resource-group test-fst\n</code></pre>"},{"location":"deployment/#api","title":"API","text":"<p>The API uses compiled artifacts for the giellalt language models. Specifically, each language should be compiled with</p> <pre><code>cd giellalt/lang-xxx\n./configure --enable-fst-hyphenator --enable-spellers --enable-tokenisers --enable-phonetic --enable-tts\n</code></pre> <p>There are some 40-50 different languages, many of which takes a long time to compile. For local development, using whichever files are already on your system will be fine, and the site will show grayed out languages and tools when the required files are not present.</p>"},{"location":"deployment/#buildpy","title":"build.py","text":"<p>The build.py script runs various dockerfiles. First an image called fst-compiler will be built. It contains the hfst tools used to compile the language models. Each individual language is then built in an image called fst-lang-{lang}. These images use the fst-compiler image as a base, and compiles each artifact for that language. Finally, an image that includes the necessary artifacts for all languages, as well as the application itself, called fst-app will be built.</p> <p>The images of each language will be built in parallel, but the entire process will take a long time.</p>"},{"location":"docsdocs/","title":"Meta Documentation","text":"<p>Meta documentation, i.e. documentation about the documentation.</p> <p>This is the same document as docs/README.md.</p> <p>The documentation is an mkdocs site, with the material theme. Documentation is written as markdown files, and gets rendered to html with a nice theme by these tools.</p>"},{"location":"docsdocs/#view","title":"View","text":"<p>The documentation is hosted on Github Pages:</p> <p>https://giellatekno.github.io/fst-web-interface/</p> <p>If the documentation is built locally (see below), it is available in the site/ folder. Just open up the index.html page in a browser to view the documentation.</p> <pre><code>firefox site/index.html\n</code></pre>"},{"location":"docsdocs/#writing-documentation","title":"Writing documentation","text":""},{"location":"docsdocs/#first-time-setup","title":"First time setup","text":"<p>mkdocs is a python tool. Create a virtual environment, activate it, and install the requirements. The first and last step is only done once.</p> <pre><code>python3 -m venv .venv\n. .venv/bin/activate\npip install -r -requirements.txt\n</code></pre> <p>When coming back to the documentation, only the second command (<code>. .venv/bin/activate</code>), needs to be run.</p>"},{"location":"docsdocs/#writing-and-serving","title":"Writing and serving","text":"<p>In order to write documentation, just write markdown files, in the docs/ folder. To be able to see the generated html output while writing, mkdocs can be run with </p> <pre><code>mkdocs serve\n</code></pre> <p>If the fst-web-interface application is also running, the default port will be used. Specify another one with:</p> <pre><code>mkdocs serve -a localhost:8001\n</code></pre> <p>Open up a browser at that address to see the generated documentation as you write it.</p>"},{"location":"docsdocs/#building","title":"Building","text":"<p>To automatically build and publish the documentation on Github Pages, it's all done in a single command:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>To build the final documentation site locally, use</p> <pre><code>mkdocs build\n</code></pre> <p>It ends up as a static build in the site/ directory, as mentioned above.</p>"},{"location":"local-development/","title":"Local development","text":""},{"location":"local-development/#prerequisites","title":"Prerequisites","text":"<p>Being a web project, make sure to have a working version of node, as well as npm (or pnpm) installed on your system.</p> <p>Packages called <code>node</code> or <code>nodejs</code> should be available in most distributions. nvm (\"node version manager\") is an alternative great way to be able to have mulitple versions of node installed on a system, and quickly switch between them.</p> <p>For FastAPI, the minimum required python version is 3.10. Check the locally installed python version with <code>python3 --version</code>. pyenv (python version manager) will let you install mulitple python versions on your system, and switch between them. It's basically for Python what nvm is for node.</p>"},{"location":"local-development/#installation","title":"Installation","text":"<p>To run the development server, navigate to the folder after cloning, and install the dependencies.</p> <pre><code>git clone https://github.com/giellatekno/fst-web-interface\ncd fst-web-interface/client\nnpm install\nnpm run dev\n</code></pre> <p>Now visit the locally running development server at localhost:5173. Modifications to source files will instantly be reflected in the browser window, due to something called \"hot module reloading\".</p> <p>To run the api in development, navigate to the folder, create a virtual environment, install requirements, and then run the web server:</p> <pre><code>cd fst-web-interface/api\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\nuvicorn src.main:app --reload\n</code></pre> <p>Now the API is accessible at port 8000, and two different OpenAPI schema explorers are available at /redoc and /docs. In my opinon, the /redoc one is nicer, but the /docs one will let you test queries to the API directly on the documentation site.</p>"},{"location":"local-development/#development-after-initial-setup","title":"Development after initial setup","text":"<p>For the front-end app, <code>npm install</code> is only required when first setting up the development. Likewise, for python, the steps to install the virtual environment (<code>python -m venv .venv</code>) and installing required packages (<code>pip install -r requirements.txt</code>) are first-time-only required steps.</p>"},{"location":"local-development/#resources","title":"Resources","text":"<p>The javascript frontend framework in this project is Svelte. Read about it at svelte.dev.</p> <p>The API framework is FastAPI. Read about it at fastapi.tiangolo.com.</p>"}]}